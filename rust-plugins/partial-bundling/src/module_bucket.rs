use std::mem::replace;

use farmfe_core::{
  hashbrown::{HashMap, HashSet},
  module::{module_graph::ModuleGraph, ModuleId, ModuleType},
};

use crate::{
  config::PartialBundlingModuleBucketsConfig,
  resource_group::{ResourceGroup, ResourceUnit},
  utils::{ids_to_string, is_subset},
  ModuleGroupRedirectResourceMap, ResourceUnitId,
};

/// A ModuleBucket is a collection of modules in the same ModuleGroup.
/// By default, a ModuleBucket is generated by following rule:
/// The modules which are in the same ModuleGroups are in the same ModuleBucket. For example, if there are two ModuleGroups A and B. if module c is in ModuleGroup A and ModuleGroup B, module d is only in ModuleGroup A, then c and d are in the different ModuleBucket.
///
/// A ModuleBucket can generate multiple ResourcePots.
#[derive(Debug)]
pub struct ModuleBucket {
  pub id: ModuleBucketId,
  modules: HashSet<ModuleId>,
  pub config: PartialBundlingModuleBucketsConfig,
  pub resource_units: HashSet<ResourceUnitId>,
  pub size: HashMap<ModuleType, usize>,
}

impl ModuleBucket {
  pub fn new(id: ModuleBucketId, config: PartialBundlingModuleBucketsConfig) -> Self {
    Self {
      id,
      modules: HashSet::new(),
      config,
      resource_units: HashSet::new(),
      size: HashMap::new(),
    }
  }

  pub fn modules(&self) -> &HashSet<ModuleId> {
    &self.modules
  }

  pub fn resource_units(&self) -> &HashSet<ResourceUnitId> {
    &self.resource_units
  }

  fn add_size(&mut self, module_type: &ModuleType, size: usize) {
    if !self.size.contains_key(module_type) {
      self.size.insert(module_type.clone(), 0);
    }

    *self.size.get_mut(module_type).unwrap() += size;
  }

  fn sub_size(&mut self, module_type: &ModuleType, size: usize) {
    if self.size.contains_key(module_type) {
      let v = self.size.get_mut(module_type).unwrap();
      *v = v.saturating_sub(size);
    }
  }

  pub fn total_size(&self) -> u128 {
    self.size.values().fold(0, |r, s| r + (*s as u128))
  }

  pub fn add_module(&mut self, module_id: ModuleId, module_type: &ModuleType, size: usize) {
    self.modules.insert(module_id);
    self.add_size(module_type, size);
  }

  pub fn replace_modules(&mut self, module_graph: &ModuleGraph, modules: HashSet<ModuleId>) {
    self.size = HashMap::default();

    for module_id in &modules {
      let module = module_graph.module(module_id).unwrap();
      self.add_size(&module.module_type, module.size);
    }

    self.modules = modules;
  }

  pub fn take_modules(&mut self) -> HashSet<ModuleId> {
    replace(&mut self.modules, HashSet::new())
  }

  pub fn add_resource_pot(&mut self, resource_pot_id: ResourceUnitId) {
    self.resource_units.insert(resource_pot_id);
  }

  pub fn remove_module(
    &mut self,
    module_id: &ModuleId,
    module_type: &ModuleType,
    size: usize,
  ) -> bool {
    self.sub_size(module_type, size);

    self.modules.remove(module_id)
  }
}

pub fn find_best_process_bucket(
  module_bucket_ids: &HashSet<ModuleBucketId>,
  module_bucket_map: &HashMap<ModuleBucketId, ModuleBucket>,
) -> ModuleBucketId {
  module_bucket_ids
    .iter()
    .reduce(|a, b| {
      let module_bucket_1 = module_bucket_map.get(a).unwrap();
      let module_bucket_2 = module_bucket_map.get(b).unwrap();

      let r = module_bucket_1
        .config
        .weight
        .cmp(&module_bucket_2.config.weight);
      if !r.is_eq() {
        return if r.is_gt() { a } else { b };
      }

      let a_units_len = module_bucket_1.resource_units().len();
      let b_units_len = module_bucket_2.resource_units().len();

      let r = a_units_len.cmp(&b_units_len);

      if !r.is_eq() {
        return if r.is_gt() { a } else { b };
      }

      let r = ((module_bucket_1.total_size()) * (a_units_len as u128))
        .cmp(&(module_bucket_2.total_size() * b_units_len as u128));

      if !r.is_eq() {
        return if r.is_gt() { a } else { b };
      }

      a
    })
    .unwrap()
    .clone()
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleBucketId {
  id: String,
}

impl From<String> for ModuleBucketId {
  fn from(id: String) -> Self {
    Self { id }
  }
}

impl ToString for ModuleBucketId {
  fn to_string(&self) -> String {
    self.id.clone()
  }
}

pub fn add_module_to_bucket(
  module_bucket_id: ModuleBucketId,
  module_bucket_map: &mut HashMap<ModuleBucketId, ModuleBucket>,
  bucket_config: PartialBundlingModuleBucketsConfig,
  resource_units: HashSet<ResourceUnitId>,
  module_id: &ModuleId,
  module_type: &ModuleType,
  size: usize,
) {
  let module_bucket = module_bucket_map
    .entry(module_bucket_id.clone())
    .or_insert_with(|| ModuleBucket::new(module_bucket_id.clone(), bucket_config));

  module_bucket.add_module(module_id.clone(), module_type, size);

  for resource_pot_id in resource_units {
    module_bucket.add_resource_pot(resource_pot_id);
  }
}

pub fn generate_module_buckets(
  modules: &Vec<ModuleId>,
  module_graph: &ModuleGraph,
  module_buckets: &[PartialBundlingModuleBucketsConfig],
  group_redirect_resource_unit_map: &ModuleGroupRedirectResourceMap,
  module_group_map: &HashMap<ModuleId, Vec<ModuleId>>,
  resource_pot_sets: Vec<Vec<String>>,
) -> HashMap<ModuleBucketId, ModuleBucket> {
  let mut module_bucket_map = HashMap::<ModuleBucketId, ModuleBucket>::new();

  // gen bucket map
  for module_id in modules {
    let module = module_graph.module(module_id).unwrap();
    // Skip the external modules
    if module.external {
      continue;
    }

    if !module.resource_pot.is_empty() {
      panic!(
        "Module {:?} has already been assigned to a resource pot: {:?}.",
        module_id,
        module
          .resource_pot
          .iter()
          .map(|item| item.to_string())
          .collect::<Vec<_>>()
      );
    }

    let module_relation_resource_pot_ids: Vec<ResourceUnitId> = {
      let mut result: HashSet<ResourceUnitId> = Default::default();

      for module_group in module_group_map[module_id].iter() {
        if let Some(resource_unit) = group_redirect_resource_unit_map.get(module_group) {
          result.insert(resource_unit.clone());
        }
      }

      result.into_iter().collect()
    };

    module_buckets
      .iter()
      .filter(|bucket_config| {
        let regex = &bucket_config.test;
        regex.is_empty() || regex.iter().any(|r| r.is_match(&module_id.to_string()))
      })
      .for_each(|bucket_config| {
        let mut relation_resource_all_pots = vec![];

        for resource_pot_set in resource_pot_sets.iter() {
          if is_subset(resource_pot_set, &module_relation_resource_pot_ids) {
            let resources: HashSet<ResourceUnitId> = resource_pot_set.iter().cloned().collect();
            relation_resource_all_pots.push(resources);
          };
        }

        for resource_pot_id in module_relation_resource_pot_ids.iter() {
          let sets = HashSet::from([resource_pot_id.clone()]);
          relation_resource_all_pots.push(sets);
        }

        for resource_units in relation_resource_all_pots.into_iter() {
          let module_bucket_id = format!(
            "{}-{}",
            bucket_config.name,
            ids_to_string(resource_units.iter())
          )
          .into();

          add_module_to_bucket(
            module_bucket_id,
            &mut module_bucket_map,
            bucket_config.clone(),
            resource_units,
            module_id,
            &module.module_type,
            module.size,
          );
        }
      });
  }

  module_bucket_map
}

/// remove module bucket by min_size
pub fn remove_module_bucket_by_size(
  module_graph: &ModuleGraph,
  module_bucket_map: &mut HashMap<ModuleBucketId, ModuleBucket>,
) {
  let remove_module_buckets = module_bucket_map
    .values_mut()
    .filter_map(|module_bucket| {
      if let Some(min_size) = module_bucket.config.min_size {
        let size = &module_bucket.size;

        let size = size
          .iter()
          .filter(|(_, v)| **v < min_size)
          .map(|(k, _)| k.clone())
          .collect::<Vec<_>>();

        if size.is_empty() {
          return None;
        }

        let new_modules: HashSet<ModuleId> = module_bucket
          .take_modules()
          .into_iter()
          .filter_map(|module_id| {
            let module_type = module_graph
              .module(&module_id)
              .map(|module| &module.module_type)
              .unwrap();
            if size.contains(module_type) {
              None
            } else {
              Some(module_id)
            }
          })
          .collect();

        module_bucket.replace_modules(module_graph, new_modules);

        if module_bucket.modules().is_empty() {
          return Some(module_bucket.id.clone());
        }
      }
      None
    })
    .collect::<Vec<_>>();

  remove_module_buckets.iter().for_each(|bucket_id| {
    module_bucket_map.remove(bucket_id);
  });
}

/// gen resource unit by module_bucket
pub fn gen_resource_unit_by_module_buckets(
  module_graph: &mut ModuleGraph,
  module_bucket_map: &mut HashMap<ModuleBucketId, ModuleBucket>,
  resource_group: &mut ResourceGroup,
) {
  let mut module_bucket_ids: HashSet<ModuleBucketId> = module_bucket_map.keys().cloned().collect();

  // gen resource unit by module_bucket
  while !module_bucket_ids.is_empty() {
    let cur_process_module_bucket_id =
      find_best_process_bucket(&module_bucket_ids, module_bucket_map);

    let cur_process_module_bucket_id = module_bucket_ids
      .take(&cur_process_module_bucket_id)
      .unwrap();

    let module_bucket = module_bucket_map
      .remove(&cur_process_module_bucket_id)
      .expect("failed read module bucket");

    let mut bucket_resource_units = module_bucket.resource_units.clone();

    // remove bucket resource unit of groups > max request
    if let Some(max_requests) = module_bucket.config.max_concurrent_requests {
      let mut result = vec![];
      for resource_unit_id in bucket_resource_units.iter() {
        let groups = resource_group.deps(resource_unit_id);
        if groups.len() >= max_requests as usize {
          result.push(resource_unit_id.clone());
        };
      }
      result.iter().for_each(|resource_pot_id| {
        bucket_resource_units.remove(resource_pot_id);
      });
    }

    // transfer to other resource_unit
    if bucket_resource_units.len() < module_bucket.resource_units.len() {
      let bucket_config = module_bucket.config.clone();

      if !bucket_resource_units.is_empty() {
        let module_bucket_id: ModuleBucketId = format!(
          "{}-{}",
          bucket_config.name,
          ids_to_string(bucket_resource_units.iter())
        )
        .into();

        for module_id in module_bucket.modules().clone() {
          let module = module_graph.module(&module_id).unwrap();
          module_bucket_ids.insert(module_bucket_id.clone());
          add_module_to_bucket(
            module_bucket_id.clone(),
            module_bucket_map,
            bucket_config.clone(),
            bucket_resource_units.clone(),
            &module_id,
            &module.module_type,
            module.size,
          );
        }
      }

      continue;
    }

    if module_bucket.modules().is_empty() {
      continue;
    }

    let resource_pot_group = {
      let resource_pot = ResourceUnit::new(module_bucket.config.name.clone());
      let id = resource_pot.id.clone();

      resource_group.add_resource_pot(resource_pot);

      resource_group.group_mut(&id).unwrap()
    };

    let resource_unit_id = resource_pot_group.resource_unit.id.clone();

    bucket_resource_units
      .iter()
      .for_each(|resource_pot_id_of_module_group| {
        resource_pot_group.add_group(resource_pot_id_of_module_group)
      });

    for module_id in module_bucket.modules() {
      let module = module_graph.module_mut(module_id).unwrap();

      // delete in bucket module
      for bucket_id in module_bucket_ids.iter() {
        // TODO: this bucket resource pot is out module bucket subset
        let bucket = module_bucket_map.get_mut(bucket_id).unwrap();
        bucket.remove_module(module_id, &module.module_type, module.size);
      }

      // delete in other resource_pot module
      for bucket_resource_unit in bucket_resource_units.iter() {
        resource_group
          .resource_unit_mut(bucket_resource_unit)
          .unwrap()
          .remove_module(module_id);
      }

      resource_group
        .resource_unit_mut(&resource_unit_id)
        .unwrap()
        .add_module(module_id.clone());
    }
  }
}
