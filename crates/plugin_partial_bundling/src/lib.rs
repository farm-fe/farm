use std::{collections::VecDeque, sync::Arc};

use farmfe_core::{
  config::Config,
  context::CompilationContext,
  hashbrown::{HashMap, HashSet},
  module::{
    module_graph::ModuleGraph,
    module_group::{ModuleGroup, ModuleGroupGraph},
    ModuleId, ModuleType,
  },
  plugin::{Plugin, PluginHookContext},
  resource::resource_pot::{ResourcePot, ResourcePotId},
};
use farmfe_toolkit::hash::sha256;
use module_bucket::{ModuleBucket, ModuleBucketId};

mod module_bucket;

pub struct FarmPluginPartialBundling {}

impl Plugin for FarmPluginPartialBundling {
  fn name(&self) -> &str {
    "FarmPluginPartialBundling"
  }

  fn priority(&self) -> i32 {
    99
  }

  fn analyze_module_graph(
    &self,
    module_graph: &mut ModuleGraph,
    _context: &Arc<CompilationContext>,
    _hook_context: &PluginHookContext,
  ) -> farmfe_core::error::Result<Option<ModuleGroupGraph>> {
    let module_group_graph = module_group_graph_from_entries(
      &module_graph
        .entries
        .clone()
        .into_iter()
        .map(|(entry, _)| entry)
        .collect(),
      module_graph,
    );

    Ok(Some(module_group_graph))
  }

  /// The partial bundling algorithm's result should not be related to the order of the module group.
  /// Whatever the order of the module group is, the result should be the same.
  fn partial_bundling(
    &self,
    modules: &Vec<ModuleId>,
    context: &Arc<CompilationContext>,
    _hook_context: &PluginHookContext,
  ) -> farmfe_core::error::Result<Option<Vec<ResourcePot>>> {
    let mut module_graph = context.module_graph.write();
    let mut resource_pots = vec![];

    // First, generate ModuleBucket
    let mut module_bucket_map = HashMap::<ModuleBucketId, ModuleBucket>::new();

    for module_id in modules {
      let module = module_graph.module(module_id).unwrap();
      // Skip the external modules
      if module.external {
        continue;
      }

      if module.resource_pot.is_some() {
        panic!(
          "Module {:?} has already been assigned to a resource pot: {:?}.",
          module_id,
          module.resource_pot.as_ref().unwrap()
        );
      }

      let add_module = |module_bucket_id: ModuleBucketId,
                        module_bucket_map: &mut HashMap<ModuleBucketId, ModuleBucket>,
                        customized_by_user: bool| {
        if module_bucket_map.contains_key(&module_bucket_id) {
          let module_bucket = module_bucket_map.get_mut(&module_bucket_id).unwrap();
          module_bucket.add_module(module_id.clone());
        } else {
          let mut module_bucket =
            ModuleBucket::new(module_bucket_id.clone(), HashSet::new(), customized_by_user);
          module_bucket.add_module(module_id.clone());
          module_bucket_map.insert(module_bucket_id, module_bucket);
        }
      };

      let mut module_in_custom_buckets = false;

      for bucket_config in &context.config.partial_bundling.module_buckets {
        let bucket_name = &bucket_config.name;

        let regex = &bucket_config.test;

        if regex.iter().any(|r| r.is_match(&module_id.to_string())) {
          module_in_custom_buckets = true;

          let bucket_id: ModuleBucketId = bucket_name.clone().into();
          add_module(bucket_id, &mut module_bucket_map, true);
        }
      }

      // The module is already in a resource pot, skip it.
      if module_in_custom_buckets {
        continue;
      }

      let module_group_ids = module.module_groups.clone();
      let module_bucket_id = ModuleBucketId::new(module_group_ids);
      add_module(module_bucket_id, &mut module_bucket_map, false);
    }

    // Second, for each ModuleBucket, generate ResourcePot.
    // The ResourcePot is generated by following rule:
    // 1. Different ModuleType should be in different ResourcePot.
    // 2. Mutable and immutable module should be in different ResourcePot.
    // 3. The modules in the same Package should be in the same ResourcePot.
    // 4. Every Module should be only in a ResourcePot.
    // 5. TODO: auto detected the resource pot's size and split it into multiple resource pots.

    for module_bucket in module_bucket_map.values() {
      let mut rules_map = HashMap::<(ModuleType, bool), Vec<ModuleId>>::new();

      for module_id in module_bucket.modules() {
        let module = module_graph.module(module_id).unwrap();

        let rule = if module_bucket.customized_by_user {
          (module.module_type.clone(), false)
        } else {
          (module.module_type.clone(), module.immutable)
        };

        if rules_map.contains_key(&rule) {
          let module_ids = rules_map.get_mut(&rule).unwrap();
          module_ids.push(module_id.clone());
        } else {
          rules_map.insert(rule, vec![module_id.clone()]);
        }
      }

      for (rule, module_ids) in rules_map.into_iter() {
        let (module_type, immutable) = rule;
        let mut sorted_module_ids = module_ids.iter().map(|m| m.to_string()).collect::<Vec<_>>();
        sorted_module_ids.sort();

        let id = sha256(
          format!(
            "{}-{}-{}-{}",
            module_bucket.id.to_string(),
            module_type.to_string(),
            sorted_module_ids.join("_"),
            immutable
          )
          .as_bytes(),
          8,
        );
        let mut resource_pot = ResourcePot::new(ResourcePotId::new(id), module_type.into());

        resource_pot.immutable = immutable;

        for module_id in module_ids {
          let module = module_graph.module_mut(&module_id).unwrap();
          module.resource_pot = Some(resource_pot.id.clone());
          resource_pot.add_module(module_id.clone());

          if module_graph.entries.contains_key(&module_id) {
            resource_pot.entry_module = Some(module_id.clone());
          }
        }

        resource_pots.push(resource_pot);
      }
    }

    Ok(Some(resource_pots))
  }
}

impl FarmPluginPartialBundling {
  pub fn new(_: &Config) -> Self {
    Self {}
  }
}

pub fn module_group_graph_from_entries(
  entries: &Vec<ModuleId>,
  module_graph: &mut ModuleGraph,
) -> ModuleGroupGraph {
  let mut module_group_graph = ModuleGroupGraph::new();
  let mut edges = vec![];
  let mut visited = HashSet::new();

  for entry in entries.clone() {
    let (group, dynamic_dependencies) = module_group_from_entry(&entry, module_graph);
    edges.extend(
      dynamic_dependencies
        .clone()
        .into_iter()
        .map(|dep| (group.id.clone(), dep)),
    );

    module_group_graph.add_module_group(group);

    visited.insert(entry);
    let mut queue = VecDeque::from(dynamic_dependencies);

    while !queue.is_empty() {
      let head = queue.pop_front().unwrap();

      if visited.contains(&head) {
        continue;
      }

      visited.insert(head.clone());

      let (group, dynamic_dependencies) = module_group_from_entry(&head, module_graph);
      edges.extend(
        dynamic_dependencies
          .clone()
          .into_iter()
          .map(|dep| (group.id.clone(), dep)),
      );

      module_group_graph.add_module_group(group);
      queue.extend(dynamic_dependencies);
    }
  }

  for (from, to) in &edges {
    module_group_graph.add_edge(from, to);
  }

  module_group_graph
}

/// get module group start from a entry. return (module group, dynamic dependencies)
/// traverse the module graph using bfs, stop when reach a dynamic dependency
fn module_group_from_entry(
  entry: &ModuleId,
  graph: &mut ModuleGraph,
) -> (ModuleGroup, Vec<ModuleId>) {
  let mut visited = HashSet::new();
  let mut module_group = ModuleGroup::new(entry.clone());
  let mut dynamic_entries = vec![];

  graph
    .module_mut(entry)
    .unwrap()
    .module_groups
    .insert(entry.clone());

  visited.insert(entry.clone());

  let deps = graph
    .dependencies(entry)
    .into_iter()
    .map(|(k, v)| (k, v.is_dynamic()))
    .collect::<Vec<_>>();

  for (dep, is_dynamic) in deps {
    if is_dynamic {
      dynamic_entries.push(dep);
    } else {
      // visited all dep and its dependencies using BFS
      let mut queue = VecDeque::new();
      queue.push_back(dep.clone());

      while !queue.is_empty() {
        let head = queue.pop_front().unwrap();

        if visited.contains(&head) {
          continue;
        }

        visited.insert(head.clone());
        module_group.add_module(head.clone());
        graph
          .module_mut(&head)
          .unwrap()
          .module_groups
          .insert(entry.clone());

        for (dep, edge) in graph.dependencies(&head) {
          if edge.is_dynamic() {
            dynamic_entries.push(dep);
          } else {
            queue.push_back(dep);
          }
        }
      }
    }
  }

  (module_group, dynamic_entries)
}

#[cfg(test)]
mod tests {
  use std::{collections::HashMap, sync::Arc};

  use farmfe_core::{
    context::CompilationContext,
    hashbrown::HashSet,
    parking_lot::RwLock,
    plugin::{Plugin, PluginHookContext},
  };
  #[cfg(test)]
  use farmfe_testing_helpers::construct_test_module_graph;
  use farmfe_testing_helpers::construct_test_module_group_graph;

  use crate::{module_group_from_entry as mgfe, FarmPluginPartialBundling};

  #[test]
  fn analyze_module_graph() {
    let plugin = FarmPluginPartialBundling {};
    let mut context = CompilationContext::new(Default::default(), vec![]).unwrap();
    let graph = construct_test_module_graph();

    let _ = std::mem::replace(&mut context.module_graph, Box::new(RwLock::new(graph)));
    let context = Arc::new(context);
    let mut module_graph = context.module_graph.write();

    let module_group_graph = plugin
      .analyze_module_graph(
        &mut module_graph,
        &context,
        &PluginHookContext {
          caller: None,
          meta: HashMap::new(),
        },
      )
      .unwrap()
      .unwrap();

    assert_eq!(module_group_graph.len(), 5);
    assert!(module_group_graph.has(&"A".into()));
    assert!(module_group_graph.has(&"B".into()));
    assert!(module_group_graph.has(&"D".into()));
    assert!(module_group_graph.has(&"F".into()));
    assert!(module_group_graph.has(&"G".into()));

    let module_group_a = module_group_graph.module_group(&"A".into()).unwrap();
    assert_eq!(module_group_a.id, "A".into());
    assert_eq!(
      module_group_a.modules(),
      &HashSet::from(["A".into(), "C".into()])
    );

    let module_group_b = module_group_graph.module_group(&"B".into()).unwrap();
    assert_eq!(module_group_b.id, "B".into());
    assert_eq!(
      module_group_b.modules(),
      &HashSet::from(["B".into(), "D".into(), "E".into()])
    );

    let module_group_d = module_group_graph.module_group(&"D".into()).unwrap();
    assert_eq!(module_group_d.id, "D".into());
    assert_eq!(module_group_d.modules(), &HashSet::from(["D".into()]));

    let module_group_f = module_group_graph.module_group(&"F".into()).unwrap();
    assert_eq!(module_group_f.id, "F".into());
    assert_eq!(
      module_group_f.modules(),
      &HashSet::from(["F".into(), "A".into(), "C".into()])
    );

    let module_group_g = module_group_graph.module_group(&"G".into()).unwrap();
    assert_eq!(module_group_g.id, "G".into());
    assert_eq!(module_group_g.modules(), &HashSet::from(["G".into()]));

    let test_pairs = vec![(
      "A",
      vec!["A", "F"],
      ("B", vec!["B"]),
      ("C", vec!["A", "F"]),
      ("D", vec!["D", "B"]),
      ("E", vec!["B"]),
      ("F", vec!["F"]),
      ("G", vec!["G"]),
    )];

    for tp in test_pairs {
      let m_a = module_graph.module_mut(&tp.0.into()).unwrap();
      assert_eq!(m_a.module_groups.len(), tp.1.len());

      for g_id in tp.1 {
        assert!(m_a.module_groups.contains(&g_id.into()));
      }
    }
  }

  #[test]
  fn module_group_from_entry() {
    let mut graph = construct_test_module_graph();

    let (module_group, de) = mgfe(&"A".into(), &mut graph);
    assert_eq!(de, vec!["F".into(), "D".into()]);
    assert_eq!(module_group.id, "A".into());
    assert_eq!(
      module_group.modules(),
      &HashSet::from(["A".into(), "C".into()])
    );
    assert!(graph
      .module(&"A".into())
      .unwrap()
      .module_groups
      .contains(&"A".into()));
    assert!(graph
      .module(&"C".into())
      .unwrap()
      .module_groups
      .contains(&"A".into()));
  }

  #[test]
  fn module_group_graph_from_entries() {
    let mut graph = construct_test_module_graph();

    let entries = vec!["A".into(), "B".into()];
    let module_group_graph = crate::module_group_graph_from_entries(&entries, &mut graph);
    let final_module_group_graph = construct_test_module_group_graph();

    assert_eq!(module_group_graph, final_module_group_graph);
  }
}
