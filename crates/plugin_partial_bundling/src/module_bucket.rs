use farmfe_core::{
  hashbrown::HashSet,
  module::{module_group::ModuleGroupId, ModuleId},
};

/// A ModuleBucket is a collection of modules in the same ModuleGroup.
/// By default, a ModuleBucket is generated by following rule:
/// The modules which are in the same ModuleGroups are in the same ModuleBucket. For example, if there are two ModuleGroups A and B. if module c is in ModuleGroup A and ModuleGroup B, module d is only in ModuleGroup A, then c and d are in the different ModuleBucket.
///
/// A ModuleBucket can generate multiple ResourcePots.
#[derive(Debug)]
pub struct ModuleBucket {
  pub id: ModuleBucketId,
  pub isolate: bool,
  modules: HashSet<ModuleId>,
}

impl ModuleBucket {
  pub fn new(id: ModuleBucketId, modules: HashSet<ModuleId>) -> Self {
    Self {
      id,
      modules,
      isolate: false,
    }
  }

  pub fn modules(&self) -> &HashSet<ModuleId> {
    &self.modules
  }

  pub fn add_module(&mut self, module_id: ModuleId) {
    self.modules.insert(module_id);
  }

  pub fn remove_module(&mut self, module_id: &ModuleId) -> bool {
    self.modules.remove(module_id)
  }

  pub fn has_module(&self, module_id: &ModuleId) -> bool {
    self.modules.contains(module_id)
  }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleBucketId {
  id: String,
}

impl From<String> for ModuleBucketId {
  fn from(id: String) -> Self {
    Self { id }
  }
}

impl ToString for ModuleBucketId {
  fn to_string(&self) -> String {
    self.id.clone()
  }
}

impl ModuleBucketId {
  pub fn new(module_group_ids: HashSet<ModuleGroupId>) -> Self {
    let mut module_group_ids = module_group_ids
      .into_iter()
      .map(|id| id.to_string())
      .collect::<Vec<String>>();
    module_group_ids.sort();

    let id = module_group_ids
      .clone()
      .into_iter()
      .collect::<Vec<String>>()
      .join("_");

    Self { id }
  }
}
