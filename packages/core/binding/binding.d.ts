/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Compiler {
  constructor(config: object)
  traceDependencies(): object
  traceModuleGraph(): object
  /** async compile, return promise */
  compile(): object
  /** sync compile */
  compileSync(): void
  /** TODO: usage example */
  update(paths: Array<[string, string]>, threadSafeCallback: ((err: Error | null, ) => any), sync: boolean, generateUpdateResource: boolean): object
  addWatchFiles(root: string, paths: Array<string>): void
  hasModule(resolvedPath: string): boolean
  getParentFiles(resolvedPath: string): Array<string>
  resources(): Record<string, Buffer>
  resourcesMap(): Record<string, unknown>
  writeResourcesToDisk(): void
  watchModules(): Array<string>
  relativeModulePaths(): Array<string>
  resource(name: string): Buffer | null
  stats(): string
  invalidateModule(moduleId: string): void
  /** Write cache with name and data */
  writeCache(name: string, data: string, options?: JsApiMetadata | undefined | null): void
  /** Read cache with name, return `undefined` if not exists */
  readCache(name: string, options?: JsApiMetadata | undefined | null): string | null
}
export type JsCompiler = Compiler

export declare class Resolver {
  constructor(config: object)
  resolve(source: string, baseDir: string, dynamicExtensions?: Array<string> | undefined | null): string
}
export type JsResolver = Resolver

export interface JsApiMetadata {
  /** Scope of the cache, used different name, same scope will hit the same cache */
  scope?: Array<string>
  /** reference ModuleId of the cache, when the module is invalidated, the cache will be invalidated too */
  refer?: Array<string>
}

export interface JsModuleHookFilters {
  moduleTypes?: Array<string>
  resolvedPaths?: Array<string>
}

export interface JsPluginAugmentResourceHashHookFilters {
  resourcePotTypes: Array<string>
  moduleIds: Array<string>
}

export interface JsPluginLoadHookFilters {
  resolvedPaths: Array<string>
}

export interface JsPluginProcessRenderedResourcePotHookFilters {
  resourcePotTypes: Array<string>
  moduleIds: Array<string>
}

/** Resolve hook filters, works as `||`. If any importers or sources matches any regex item in the Vec, we treat it as filtered. */
export interface JsPluginResolveHookFilters {
  importers: Array<string>
  sources: Array<string>
}

export declare const enum JsPluginTransformHtmlHookOrder {
  Pre = 0,
  Normal = 1,
  Post = 2
}

export interface JsTracedModule {
  id: string
  contentHash: string
  packageName: string
  packageVersion: string
}

export interface JsTracedModuleGraph {
  root: string
  modules: Array<JsTracedModule>
  edges: Record<string, Array<string>>
  reverseEdges: Record<string, Array<string>>
}

export interface JsUpdateResult {
  added: Array<string>
  changed: Array<string>
  removed: Array<string>
  immutableModules: string
  mutableModules: string
  boundaries: Record<string, Array<Array<string>>>
  dynamicResourcesMap?: Record<string, Array<Array<string>>>
  extraWatchResult: WatchDiffResult
}

export interface WatchDiffResult {
  add: Array<string>
  remove: Array<string>
}
